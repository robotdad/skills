#!/usr/bin/env python3
"""
Check quality and integrity of downloaded images.

Verifies image files, reports dimensions, file sizes, and detects corruption.
Useful for validating batch downloads and ensuring image quality.

Generated by: image-search skill
Purpose: Image quality verification and reporting

Usage:
    # Check all images in a directory
    python check_image_quality.py --dir ./downloaded-images
    
    # Check specific files
    python check_image_quality.py --files image1.jpg image2.png
    
    # Generate detailed report
    python check_image_quality.py --dir ./images --detailed
    
    # Check for minimum dimensions
    python check_image_quality.py --dir ./images --min-width 800 --min-height 600
"""

import argparse
import sys
import os
from pathlib import Path
from typing import List, Tuple, Optional


def check_pil_available():
    """Check if PIL/Pillow is available, provide install instructions if not."""
    try:
        from PIL import Image
        return True
    except ImportError:
        print("Error: PIL/Pillow is required for image quality checking", file=sys.stderr)
        print("Install with: pip install Pillow", file=sys.stderr)
        return False


def get_image_info(filepath):
    """
    Get detailed information about an image file.
    
    Args:
        filepath: Path to image file
    
    Returns:
        Dictionary with image info or None if corrupted/invalid
    """
    from PIL import Image
    
    info = {
        'path': filepath,
        'exists': False,
        'size_bytes': 0,
        'size_kb': 0,
        'size_mb': 0,
        'width': None,
        'height': None,
        'format': None,
        'mode': None,
        'is_valid': False,
        'error': None
    }
    
    # Check file exists
    if not os.path.exists(filepath):
        info['error'] = 'File not found'
        return info
    
    info['exists'] = True
    
    # Get file size
    try:
        size_bytes = os.path.getsize(filepath)
        info['size_bytes'] = size_bytes
        info['size_kb'] = size_bytes / 1024
        info['size_mb'] = size_bytes / (1024 * 1024)
    except Exception as e:
        info['error'] = f'Cannot read file size: {e}'
        return info
    
    # Try to open and verify image
    try:
        with Image.open(filepath) as img:
            info['width'] = img.width
            info['height'] = img.height
            info['format'] = img.format
            info['mode'] = img.mode
            
            # Verify image by trying to load it
            img.verify()
            info['is_valid'] = True
            
    except Exception as e:
        info['error'] = f'Corrupted or invalid image: {e}'
        return info
    
    return info


def format_size(size_bytes):
    """Format bytes into human-readable size."""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes/1024:.1f} KB"
    else:
        return f"{size_bytes/(1024*1024):.2f} MB"


def print_image_report(info, detailed=False):
    """
    Print formatted report for a single image.
    
    Args:
        info: Image info dictionary
        detailed: Whether to show detailed information
    """
    filepath = info['path']
    filename = os.path.basename(filepath)
    
    if not info['exists']:
        print(f"✗ {filename}: {info['error']}")
        return
    
    if not info['is_valid']:
        print(f"✗ {filename}: {info['error']} ({format_size(info['size_bytes'])})")
        return
    
    # Valid image
    dimensions = f"{info['width']}×{info['height']}"
    size = format_size(info['size_bytes'])
    
    if detailed:
        print(f"✓ {filename}")
        print(f"  Dimensions: {dimensions}")
        print(f"  Format: {info['format']}")
        print(f"  Mode: {info['mode']}")
        print(f"  Size: {size}")
    else:
        print(f"✓ {filename}: {dimensions}, {size}")


def scan_directory(directory, extensions=None):
    """
    Scan directory for image files.
    
    Args:
        directory: Directory path to scan
        extensions: List of file extensions to include (default: common image formats)
    
    Returns:
        List of image file paths
    """
    if extensions is None:
        extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff', '.tif']
    
    image_files = []
    
    for ext in extensions:
        # Find all files with this extension (case-insensitive)
        image_files.extend(Path(directory).glob(f'*{ext}'))
        image_files.extend(Path(directory).glob(f'*{ext.upper()}'))
    
    return sorted(set(image_files))


def main():
    parser = argparse.ArgumentParser(
        description='Check quality and integrity of image files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Check all images in a directory
  python check_image_quality.py --dir ./downloaded-images
  
  # Check specific files
  python check_image_quality.py --files image1.jpg image2.png image3.jpg
  
  # Detailed report with all metadata
  python check_image_quality.py --dir ./images --detailed
  
  # Check for minimum dimensions
  python check_image_quality.py --dir ./posters --min-width 800 --min-height 600
  
  # Check only specific formats
  python check_image_quality.py --dir ./images --formats .jpg .png

Requirements:
  pip install Pillow
        """
    )
    
    # Input sources (mutually exclusive)
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument(
        '--dir',
        metavar='DIRECTORY',
        help='Directory to scan for images'
    )
    input_group.add_argument(
        '--files',
        nargs='+',
        metavar='FILE',
        help='Specific image files to check'
    )
    
    # Options
    parser.add_argument(
        '--detailed',
        action='store_true',
        help='Show detailed information for each image'
    )
    parser.add_argument(
        '--min-width',
        type=int,
        help='Minimum width in pixels (flag images below this)'
    )
    parser.add_argument(
        '--min-height',
        type=int,
        help='Minimum height in pixels (flag images below this)'
    )
    parser.add_argument(
        '--formats',
        nargs='+',
        metavar='EXT',
        help='File extensions to check (e.g., .jpg .png)'
    )
    
    args = parser.parse_args()
    
    # Check PIL availability
    if not check_pil_available():
        sys.exit(1)
    
    # Get list of files to check
    if args.files:
        image_files = [Path(f) for f in args.files]
    else:
        image_files = scan_directory(args.dir, args.formats)
    
    if not image_files:
        print("No image files found", file=sys.stderr)
        sys.exit(1)
    
    # Print header
    print(f"Checking {len(image_files)} image(s)...")
    print()
    sys.stdout.flush()
    
    # Check each image
    stats = {
        'total': len(image_files),
        'valid': 0,
        'invalid': 0,
        'missing': 0,
        'below_min_size': 0,
        'total_size_bytes': 0
    }
    
    for filepath in image_files:
        info = get_image_info(str(filepath))
        
        # Update statistics
        if not info['exists']:
            stats['missing'] += 1
        elif not info['is_valid']:
            stats['invalid'] += 1
        else:
            stats['valid'] += 1
            stats['total_size_bytes'] += info['size_bytes']
            
            # Check minimum dimensions
            if args.min_width and info['width'] < args.min_width:
                stats['below_min_size'] += 1
                print(f"⚠ {os.path.basename(filepath)}: Width {info['width']}px below minimum {args.min_width}px")
                continue
            if args.min_height and info['height'] < args.min_height:
                stats['below_min_size'] += 1
                print(f"⚠ {os.path.basename(filepath)}: Height {info['height']}px below minimum {args.min_height}px")
                continue
        
        # Print report
        print_image_report(info, args.detailed)
        sys.stdout.flush()
    
    # Print summary
    print()
    print("=" * 60)
    print("Quality Check Summary:")
    print(f"  Total files: {stats['total']}")
    print(f"  Valid images: {stats['valid']}")
    print(f"  Invalid/corrupted: {stats['invalid']}")
    print(f"  Missing files: {stats['missing']}")
    
    if args.min_width or args.min_height:
        print(f"  Below minimum size: {stats['below_min_size']}")
    
    if stats['valid'] > 0:
        print(f"  Total size: {format_size(stats['total_size_bytes'])}")
        print(f"  Average size: {format_size(stats['total_size_bytes'] // stats['valid'])}")
    
    print("=" * 60)
    
    # Exit with error code if any issues
    has_issues = stats['invalid'] > 0 or stats['missing'] > 0 or stats['below_min_size'] > 0
    sys.exit(1 if has_issues else 0)


if __name__ == "__main__":
    main()
